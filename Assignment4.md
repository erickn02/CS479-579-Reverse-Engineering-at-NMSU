# Summary of assignment
> SUMMARY GOES HERE, include chmod +x myscript.py

# ezcrackme1.zip

## KeyGen1
```python
#!/usr/bin/env python3

import random
import string
key = "picklecucumberl337"
print(key)
```
> For the first crack me I conducted a simple assembly language analysis, we did this example in class but I still found another way to find the answer, when I imported the crack me into Ghidra I started to make a quick analysis of the both the assembly and programmed code. While conducting this I realized that in the assembly code there was a string of the password needed to crack this crack me, then I proceeded to hardcode it into the KeyGen and succesfully complete this CrackMe.

![Screenshot from 2024-02-28 14-14-00](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/fc6920e8-fb36-4d85-91a8-4dfe075b78fd)
![Screenshot from 2024-02-28 14-18-21](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/f2176ed0-93ba-4cbb-a2da-044f73e10c50)


---
---
---
# ezcrackme2.zip

## KeyGen2
```python
#!/usr/bin/env python3

import random
import string
key = "artificialtree"
print(key)
```
> For the second CrackMe I followed the same process, before trying any Source and Sink I conduct a preliminary analysis of the Assembly and programming code provided by Ghidra. After some scrolling in the code I encountered this string of the password that I tried manually and succesfully worked.It seemed to be stored in RSI too. Then I hardcoded it into the KeyGen and properly executed it.

![Screenshot from 2024-02-28 14-26-28](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/c632c58e-8f5a-422d-b228-8c9fa165e25c)


---
---
---
# ezcrackme3.zip

## KeyGen3
```python
#!/usr/bin/env python3

import random
import string
key = "strawberrykiwi"
print(key)
```

> For the third CrackMe I tried using the same method of first analysing the Assembly and programming code provided by Ghidra, by doing this I found the string ```strawberry``` , which I tried by itself manually but it did not work. After that I had to use the Source and Sink method, by doing so I followed the path from the Sink to the Source, but I was lucky to realize midway that the password was partitioned into two variables, ```FIRST_PASSWORD1``` and ```FIRST_PASSWORD2``` . When I analized this I came to the conclusion that I was missing a part of the password, so it either had to be " item + strawberry" or "strawberry + item". Once I looked where to find the missing string I found the address and I hover the mouse on top of it, then it created a quick pop-up that told me the answer and the corresponding part of it, just like shown in the following two pictures. After that I just put the password together and hardcoded it into the KeyGen.

![Screenshot from 2024-02-28 14-43-33](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/a28e1ae4-890d-4ac3-81eb-b8d90d0160aa)
![Selected photo](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/2f6460d2-21e5-4108-9c1a-952a5e8bce75)

![Screenshot from 2024-03-01 13-57-28](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/35461a2b-be0a-4710-b040-192a31137be7)


---
---
---
# controlflow1-1.zip

## KeyGen4
```python
#!/usr/bin/env python3

import random
import string

def key_gen():
  fixed_chars = ['A', '6', None, '2', None, None, None, '%', None, None, None, None, None, None, None, '*']
  random_chars = [random.choice(string.ascii_letters + string.digits + string.punctuation) if char is None else char for char in fixed_chars]
  password = ''.join(random_chars)

  return password

print(key_gen())
```
> For the first Control Flow we have to discover its parameters, we achieve this by practicing Source and Sink method, just like we saw in class this Control Flow needs the following...
> * A key with a lenght of 16 characters.
> * A key that has fixed the following positions [ A , 6 , ~ , 2 , ~ , ~ , ~ , % , ~ , ~ , ~ , ~ , ~ , ~ , ~ , * ] 
> * Empty spots to randomize are represented as "~".

![Screenshot from 2024-02-28 17-28-42](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/03fbc19a-e17f-487e-8131-cfd84e1502c9)

> Other passwords generated by the KeyGen...
![Screenshot from 2024-03-01 13-19-14](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/98ff72ba-e2b7-4a36-8c19-e914e40517a6)

---
---
---
# controlflow2-1.zip

## KeyGen5
```python
#!/usr/bin/env python3

import random
import string

def key_gen():
  fixed_chars = [None, None, None, None, None, None, 'Y', None, '#', None, 'A', '*', None, '6', None, None]
  random_chars = [random.choice(string.ascii_letters + string.digits + string.punctuation) if char is None else char for char in fixed_chars]
  password = ''.join(random_chars)

  return password

print(key_gen())
```
> For the second Control Flow we have to discover its parameters, we achieve this by practicing Source and Sink method, just like we saw in class this Control Flow needs the following...
> * A key with a lenght of 16 characters.
> * A key that has fixed the following positions [ ~ , ~ , ~ , ~ , ~ , ~ , 'Y' , ~ , '#' , ~ , 'A' , '*' , ~ , '6' , ~ , ~ ]
> * Empty spots to randomize are represented as "~".

![Screenshot from 2024-03-01 13-49-19](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/b1e67249-20d7-4b84-8ab5-610c4a02bc52)
> Other passwords generated by the KeyGen...
![Screenshot from 2024-03-01 13-50-36](https://github.com/erickn02/CS479-579-Reverse-Engineering-at-NMSU/assets/111537523/d1e496ca-3a38-452e-91c9-b8dce374067e)

